/**
 * Minified by jsDelivr using Terser v5.15.1.
 * Original file: /npm/leaflet-arrowheads@1.4.0/src/leaflet-arrowheads.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
function modulus(e, t) { return (e % t + t) % t } function definedProps(e) { return Object.fromEntries(Object.entries(e).filter((([e, t]) => void 0 !== t))) } function isInMeters(e) { return "m" === e.toString().trim().slice(e.toString().length - 1, e.toString().length) } function isInPercent(e) { return "%" === e.toString().trim().slice(e.toString().length - 1, e.toString().length) } function isInPixels(e) { return "px" === e.toString().trim().slice(e.toString().length - 2, e.toString().length) } function pixelsToMeters(e, t) { let r = t.getCenter(), s = t.latLngToLayerPoint(r), i = { x: s.x + Number(e), y: s.y }, o = t.layerPointToLatLng(i); return t.distance(r, o) } L.Polyline.include({ arrowheads: function (e = {}) { this.options.noClip = !0; let t = Object.assign({}, { yawn: 60, size: "15%", frequency: "allvertices", proportionalToTotal: !1 }, e); return this._arrowheadOptions = t, this._hatsApplied = !0, this }, buildVectorHats: function (e) { this._arrowheads && this._arrowheads.remove(), this._ghosts && this._ghosts.remove(); let t = Object.getPrototypeOf(Object.getPrototypeOf(this.options)), r = Object.assign({}, t, this.options), s = Object.assign({}, r, e); s.smoothFactor = 1, s.fillOpacity = 1, s.fill = !!e.fill, s.interactive = !1; let i = e.size.toString(), o = []; const { frequency: n, offsets: a } = e; (a?.start || a?.end) && this._buildGhosts({ start: a.start, end: a.end }); (this._ghosts || this)._parts.forEach(((t, r) => { const a = t.map((e => this._map.layerPointToLatLng(e))), l = (() => { let e = 0; for (var r = 0; r < t.length - 1; r++)e += this._map.distance(a[r], a[r + 1]); return e })(); let h, u, p, g; if (isNaN(n) ? isInPercent(n) ? console.error("Error: arrowhead frequency option cannot be given in percent.  Try another unit.") : isInMeters(n) ? (p = n.slice(0, n.length - 1) / l, g = 1 / p, g = Math.floor(g), p = 1 / g) : isInPixels(n) && (p = (() => pixelsToMeters(n.slice(0, n.length - 2), this._map) / l)(), g = 1 / p, g = Math.floor(g), p = 1 / g) : (p = 1 / n, g = n), "allvertices" === e.frequency) u = (() => { let e = []; for (var t = 1; t < a.length; t++) { let r = L.GeometryUtil.angle(this._map, a[modulus(t - 1, a.length)], a[t]) + 180; e.push(r) } return e })(), h = a, h.shift(); else if ("endonly" === e.frequency && a.length >= 2) h = [a[a.length - 1]], u = [L.GeometryUtil.angle(this._map, a[a.length - 2], a[a.length - 1]) + 180]; else { h = []; let e = []; for (var c = 0; c < g; c++) { let t = L.GeometryUtil.interpolateOnLine(this._map, a, p * (c + 1)); t && (e.push(t), h.push(t.latLng)) } u = (() => { let t = []; for (var r = 0; r < e.length; r++) { let s = L.GeometryUtil.angle(this._map, a[e[r].predecessor + 1], a[e[r].predecessor]); t.push(s) } return t })() } let d = []; const y = (t, r = {}) => { let i = r.yawn ?? e.yawn, o = L.GeometryUtil.destination(h[c], u[c] - i / 2, t), n = L.GeometryUtil.destination(h[c], u[c] + i / 2, t), a = [[o.lat, o.lng], [h[c].lat, h[c].lng], [n.lat, n.lng]], l = e.fill ? L.polygon(a, { ...s, ...r }) : L.polyline(a, { ...s, ...r }); d.push(l) }, m = (t, r = {}) => { let i = t.slice(0, t.length - 2), o = r.yawn ?? e.yawn, n = this._map.latLngToLayerPoint(h[c]), a = u[c], l = (180 - a - o / 2) * (Math.PI / 180), p = (180 - a + o / 2) * (Math.PI / 180), g = i * Math.sin(l), y = i * Math.cos(l), m = i * Math.sin(p), f = i * Math.cos(p), _ = { x: n.x + g, y: n.y + y }, w = { x: n.x + m, y: n.y + f }, v = this._map.layerPointToLatLng(_), P = this._map.layerPointToLatLng(w), T = [[v.lat, v.lng], [h[c].lat, h[c].lng], [P.lat, P.lng]], b = e.fill ? L.polygon(T, { ...s, ...r }) : L.polyline(T, { ...s, ...r }); d.push(b) }; for (c = 0; c < h.length; c++) { let { perArrowheadOptions: r, ...s } = e; if (r = r ? r(c) : {}, r = Object.assign(s, definedProps(r)), i = r.size ?? i, isInMeters(i)) { y(i.slice(0, i.length - 1), r) } else if (isInPercent(i)) { let s = i.slice(0, i.length - 1); y((() => { if ("endonly" === e.frequency && e.proportionalToTotal) return l * s / 100; return l / (t.length - 1) * s / 100 })(), r) } else isInPixels(i) ? m(e.size, r) : console.error("Error: Arrowhead size unit not defined.  Check your arrowhead options.") } o.push(...d) })); let l = L.layerGroup(o); return this._arrowheads = l, this }, getArrowheads: function () { return this._arrowheads ? this._arrowheads : console.error("Error: You tried to call '.getArrowheads() on a shape that does not have a arrowhead.  Use '.arrowheads()' to add a arrowheads before trying to call '.getArrowheads()'") }, _buildGhosts: function ({ start: e, end: t }) { if (e || t) { let r = this.getLatLngs(); r = Array.isArray(r[0]) ? r : [r]; const s = r.map((r => { const s = (() => { let e = 0; for (var t = 0; t < r.length - 1; t++)e += this._map.distance(r[t], r[t + 1]); return e })(); if (e) { let t = (() => { if (isInMeters(e)) return Number(e.slice(0, e.length - 1)); if (isInPixels(e)) { return pixelsToMeters(Number(e.slice(0, e.length - 2)), this._map) } })(), i = L.GeometryUtil.interpolateOnLine(this._map, r, t / s); (r = r.slice(-1 === i.predecessor ? 1 : i.predecessor + 1, r.length)).unshift(i.latLng) } if (t) { let e = (() => { if (isInMeters(t)) return Number(t.slice(0, t.length - 1)); if (isInPixels(t)) { return pixelsToMeters(Number(t.slice(0, t.length - 2)), this._map) } })(), i = L.GeometryUtil.interpolateOnLine(this._map, r, (s - e) / s); (r = r.slice(0, i.predecessor + 1)).push(i.latLng) } return r })); this._ghosts = L.polyline(s, { ...this.options, color: "rgba(0,0,0,0)", stroke: 0, smoothFactor: 0, interactive: !1 }), this._ghosts.addTo(this._map) } }, deleteArrowheads: function () { this._arrowheads && (this._arrowheads.remove(), delete this._arrowheads, delete this._arrowheadOptions, this._hatsApplied = !1), this._ghosts && this._ghosts.remove() }, _update: function () { this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath(), this._hatsApplied && (this.buildVectorHats(this._arrowheadOptions), this._map.addLayer(this._arrowheads))) }, remove: function () { return this._arrowheads && this._arrowheads.remove(), this._ghosts && this._ghosts.remove(), this.removeFrom(this._map || this._mapToAdd) } }), L.LayerGroup.include({ removeLayer: function (e) { var t = e in this._layers ? e : this.getLayerId(e); return this._map && this._layers[t] && (this._layers[t]._arrowheads && this._layers[t]._arrowheads.remove(), this._map.removeLayer(this._layers[t])), delete this._layers[t], this }, onRemove: function (e, t) { for (var t in this._layers) this._layers[t] && this._layers[t].remove(); this.eachLayer(e.removeLayer, e) } }), L.Map.include({ removeLayer: function (e) { var t = L.Util.stamp(e); return e._arrowheads && e._arrowheads.remove(), e._ghosts && e._ghosts.remove(), this._layers[t] ? (this._loaded && e.onRemove(this), e.getAttribution && this.attributionControl && this.attributionControl.removeAttribution(e.getAttribution()), delete this._layers[t], this._loaded && (this.fire("layerremove", { layer: e }), e.fire("remove")), e._map = e._mapToAdd = null, this) : this } }), L.GeoJSON.include({ geometryToLayer: function (e, t) { var r, s, i, o, n = "Feature" === e.type ? e.geometry : e, a = n ? n.coordinates : null, l = [], h = t && t.pointToLayer, u = t && t.coordsToLatLng || L.GeoJSON.coordsToLatLng; if (!a && !n) return null; switch (n.type) { case "Point": return r = u(a), this._pointToLayer(h, e, r, t); case "MultiPoint": for (i = 0, o = a.length; i < o; i++)r = u(a[i]), l.push(this._pointToLayer(h, e, r, t)); return new L.FeatureGroup(l); case "LineString": case "MultiLineString": s = L.GeoJSON.coordsToLatLngs(a, "LineString" === n.type ? 0 : 1, u); var p = new L.Polyline(s, t); return t.arrowheads && p.arrowheads(t.arrowheads), p; case "Polygon": case "MultiPolygon": return s = L.GeoJSON.coordsToLatLngs(a, "Polygon" === n.type ? 1 : 2, u), new L.Polygon(s, t); case "GeometryCollection": for (i = 0, o = n.geometries.length; i < o; i++) { var g = this.geometryToLayer({ geometry: n.geometries[i], type: "Feature", properties: e.properties }, t); g && l.push(g) } return new L.FeatureGroup(l); default: throw new Error("Invalid GeoJSON object.") } }, addData: function (e) { var t, r, s, i = L.Util.isArray(e) ? e : e.features; if (i) { for (t = 0, r = i.length; t < r; t++)((s = i[t]).geometries || s.geometry || s.features || s.coordinates) && this.addData(s); return this } var o = this.options; if (o.filter && !o.filter(e)) return this; var n = this.geometryToLayer(e, o); return n ? (n.feature = L.GeoJSON.asFeature(e), n.defaultOptions = n.options, this.resetStyle(n), o.onEachFeature && o.onEachFeature(e, n), this.addLayer(n)) : this }, _pointToLayer: function (e, t, r, s) { return e ? e(t, r) : new L.Marker(r, s && s.markersInheritOptions && s) } })
